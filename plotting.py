from matplotlib.patches import Circle, Polygon, Rectangle
import numpy as np
import itertools
import pynite_tools as pt

# This is a hard-coded colormap (originally generated by the LLM [eyeroll]).
# This should be replaced with one of the matplotlib built-in colormaps (cmaps)
# Which can be selected to accommodate various kinds of colorblindness:
# https://matplotlib.org/stable/users/explain/colors/colormaps.html

LOAD_CASE_COLORS = [
    'tab:red', 'tab:blue', 'tab:green', 'tab:orange', 
    'tab:purple', 'tab:brown', 'tab:pink', 'tab:olive', 
    'tab:cyan', 'black'
]



## The following three functions are functions that I originally wrote as part of my eng_module.
## I think they work pretty well.

def envelope_min(result_arrays: dict) -> list[list[float]]:
    """
    Returns the minimum factored array across all factored result arrays in 'result_arrays'.

    'result_arrays': a dict of factored result arrays for an action on a specific framing member,
        keyed by load combo name. The result array values are a Nx2 array where the x-coordinates
        are in index 0 and the y-coordinates are in index 1
    """
    stacked_results = [result_array[1] for result_array in result_arrays.values()]
    enveloped = [
        min(results_at_station) for results_at_station in zip(*stacked_results)
    ]
    first_key = list(result_arrays.keys())[0]
    return [result_arrays[first_key][0], enveloped]


def envelope_max(result_arrays: dict) -> list[list[float]]:
    """
    Returns the maximum factored array across all factored result arrays in 'result_arrays'.

    'result_arrays': a dict of factored result arrays for an action on a specific framing member,
        keyed by load combo name. The result array values are a Nx2 array where the x-coordinates
        are in index 0 and the y-coordinates are in index 1
    """
    stacked_results = [result_array[1] for result_array in result_arrays.values()]
    enveloped = [
        max(results_at_station) for results_at_station in zip(*stacked_results)
    ]
    first_key = list(result_arrays.keys())[0]
    return [result_arrays[first_key][0], enveloped]

    

def plot_enveloped_forces(ax, analysis_model, result_type: str, load_combos: list[str], load_combo_feat: str, units: str = None):
    """
    Populates an axes and returns it
    'ax': A matplotlib axes
    'analysis_model': A Pynite.FEModel3D
    'result_type': str, one of {'shear', 'moment', 'axial', 'torque', 'deflection'}
    'load_combos': list[str], a subset of the load combos present in 'analysis_model' that you would like
        to generate the envelope over.
    'load_combo_feat': the load combo that you want to "feature" as a red line on the envelope plot.
    'units': Optional[str] = None, if provided, will indicate on the axes what units are being plotted.
        This is primarily to improve communication in the plot.  
    """
    if result_type == "shear":
        action_symbol = "Vf"
        direction = "Fy"
    elif result_type == "moment":
        action_symbol = "Mf"
        direction = "Mz"
    elif result_type == "axial":
        action_symbol = "Nf"
        direction = "axial"
    elif result_type == "torque":
        action_symbol = "Tf"
        direction = "torque"
    elif result_type == "deflection":
        direction = "dy"
        action_symbol = r"$\Delta$"
    
    
    # Enveloped Forces
    member_arrays = pt.extract_member_arrays(analysis_model, load_combinations=load_combos, actions=["Fy", "Mz"])
    # result_arrays = extract_arrays_all_combos(
    #     beam_model, result_type=result_type.lower(), direction=direction, n_points=1000
    # )
    member_names = member_arrays.keys()
    if len(member_names) > 1:
        raise ValueError("This function is currently only designed to plot models with single members")
    else:
        member_name = list(member_names)[0]
    # Plot envelope
    max_result_env = envelope_max(member_arrays[member_name]['action_arrays'][direction])
    min_result_env = envelope_min(member_arrays[member_name]['action_arrays'][direction])
    x_array = max_result_env[0]  # X-array same across all results; get the first one
    # Plot beam line
    ax.plot(x_array, [0] * len(x_array), color="k")
    
    ax.fill_between(
        x_array, y1=max_result_env[1], y2=min_result_env[1], fc="teal", alpha=0.15
    )

        # Plot beam line
    ax.plot(x_array, [0] * len(x_array), color="k")
    if load_combo_feat is not None:
        ax.plot(x_array, member_arrays[member_name]['action_arrays'][direction][load_combo_feat][1], color="r")
        if units is not None:
            ax.set_title(
                f"Max/min {result_type} envelope w/ load combo {load_combo_feat} ({units})"
            )
        else:
            ax.set_title(f"Max/min {result_type} envelope w/ load combo {load_combo_feat}")
    else:
        ax.set_title(f"Max/min {result_type} envelope")

    # Add some "padding" around the top and bottom of the plot
    ax.margins(x=0.1, y=0.1)

    # Setup the variables required for labelling
    if max(x_array) < 1000:
        loc_precision = 1
    else:
        loc_precision = -1

    max_value = max(max_result_env[1])
    min_value = min(min_result_env[1])
    delta = max(abs(max_value), abs(min_value))
    results_precision = 0
    if delta < 100:
        results_precision = 2

    max_idx = max_result_env[1].index(max_value)
    max_value_loc = max_result_env[0][max_idx]
    ax.annotate(
        xy=[max_value_loc, max_value],
        xytext=(max_value_loc * 0.7, max_value),
        text=f"{action_symbol}, max @ {round(max_value_loc, loc_precision)} = {round(max_value, results_precision)}",
    )

    min_idx = min_result_env[1].index(min_value)
    min_value_loc = min_result_env[0][min_idx]
    ax.annotate(
        xy=[min_value_loc, min_value],
        xytext=(min_value_loc * 0.7, min_value),
        text=f"{action_symbol}, min @ {round(min_value_loc, loc_precision)} = {round(min_value, results_precision)}",
    )

    ax.spines["top"].set_visible(False)
    ax.spines["left"].set_visible(False)
    ax.spines["right"].set_visible(False)
    ax.spines['bottom'].set_visible(False)

    return ax

## This function was generated by the Gemini LLM. It plots the FBD
# with stacked load cases, with relative scaling for distributed loads.
# Overall, it's pretty good but, as you play wiht it, you will find
# many rough edges (but it always executes, which is cool).

def plot_beam_fbd(model, ax):
    """
    Generates a layered free-body diagram of a PyniteFEA beam model on a 
    provided matplotlib Axes object, separating loads by load case.
    
    - Beam is a black line.
    - First support is a pin (triangle), subsequent supports are rollers (circle).
    - Applied loads are layered by load case, each with a unique color.
    - Distributed loads are shaded polygons (0.5 opacity).
    
    Args:
        model (FEModel3D): The PyniteFEA model containing the beam.
        ax (Axes): An empty matplotlib Axes object to draw the FBD on.
        
    Returns:
        Axes: The populated matplotlib Axes object.
    """
    
    # --- 1. SETUP AND BEAM GEOMETRY ---
    
    # Get all node coordinates (assuming 1D beam along X-axis, Y/Z=0)
    node_coords = {name: node.X for name, node in model.nodes.items()}
    
    # Sort nodes by their X-coordinate to plot the beam sequentially
    sorted_nodes = sorted(node_coords.items(), key=lambda item: item[1])
    X_coords = [coord for name, coord in sorted_nodes]
    Y_beam = 0 # Beam is drawn along the Y=0 axis
    
    # Draw the Beam Line
    ax.plot(X_coords, [Y_beam] * len(X_coords), color='black', linewidth=3, zorder=5)
    
    # --- 2. DRAW SUPPORTS (Unchanged from previous version) ---
    
    supported_nodes = []
    for name, node in model.nodes.items():
        if node.support_DY:
            supported_nodes.append((node.X, node.name))
    supported_nodes.sort(key=lambda x: x[0])
    
    support_height = -0.5 
    x_range = X_coords[-1] - X_coords[0] if len(X_coords) > 1 else 10 # Default range if only one node
    support_width = abs(support_height)
    
    for i, xpos_name in enumerate(supported_nodes):
        x_pos, node_name = xpos_name
        if i == 0:
            # # PIN Support (Triangle)
            # pin_vertices = np.array([
            #     [x_pos - support_width/2, support_height],
            #     [x_pos + support_width/2, support_height],
            #     [x_pos, Y_beam]
            # ])
            # pin = Polygon(pin_vertices, closed=True, color='gray', 
            #                   edgecolor='black', alpha=0.5, zorder=1)
            # ax.add_patch(pin)
            # ax.hlines(support_height, x_pos - support_width * 1.5, 
            #           x_pos + support_width * 1.5, color='black', linewidth=1, zorder=1)
            ax.plot([x_pos], [support_height], marker="^", markersize=support_width * 30, color='k', alpha=0.2)
            ax.annotate(node_name, xy=(x_pos, support_height*1.5), color='k', ha='center', size=support_width*30)
        else:
            # ROLLER Support (Circle)
            # roller_base_y = support_height
            # roller_radius = support_width / 2
            # roller = Circle((x_pos, roller_radius + roller_base_y), 
            #                     roller_radius, facecolor='black', 
            #                     edgecolor='black', linewidth=1, zorder=1, alpha=0.5)
            # ax.add_patch(roller)
            # ax.hlines(roller_base_y, x_pos - roller_radius*2, 
            #           x_pos + roller_radius*2, color='black', linewidth=1, zorder=1)
            ax.plot([x_pos], [support_height], marker="o", markersize=support_width * 30, color='k', alpha=0.2)
            ax.annotate(node_name, xy=(x_pos, support_height*1.5), color='k', ha='center', size=support_width*30)

    # --- 3. DRAW APPLIED LOADS (Layered by Load Case) ---

    # Map load case name to a unique color
    load_case_names = model.load_cases
    color_map = dict(zip(load_case_names, itertools.cycle(LOAD_CASE_COLORS)))
    
    # Base vertical offset for the first layer of loads
    layer_spacing = 1.2 # Vertical distance between load planes
    y_offset = Y_beam + 0.5 # Start plotting loads slightly above the beam
    
    # Keep track of the current vertical position for each load case
    layer_heights = {} 
    
    # Iterate through each load case to plot its loads in its own layer
    for case_name in load_case_names:
        
        # Determine the unique color and current height for this load case
        color = color_map[case_name]
        current_y = y_offset # Start plotting the load case at the current offset
        
        # --- A. Distributed Loads ---
        for name, element in model.members.items():
            for dist_load in element.DistLoads:
                # Check for element distributed loads (assuming consistent X-axis loading)
                if case_name == dist_load[-1]:
                    # CHECK: Configuration of dist loads
                    direction, mag1, mag2, x1, x2, case = dist_load
                    # Pynite uses the local x-axis to define uniform load components:
                    # w_local = (direction, w1, w2, start, end, case, self_weight)
                    # We are only considering the vertical (y) component here.
                    
                    if mag1 != 0 or mag2 != 0:
                        # Get node coordinates for the element                       
                        
                        # Determine the vertical extent of the load polygon
                        # A negative load magnitude in Pynite represents a downward load.
                        # We plot the load *above* the current_y level.
                        y_top = current_y + layer_spacing * 0.5 
    
                        # Vertices for the trapezoidal polygon:
                        # [x1, current_y], [x2, current_y], [x2, y_top_at_w_end], [x1, y_top_at_w_start]
                        
                        # Normalize load magnitudes to define polygon height,
                        # ensuring the polygon is always drawn in the correct direction (downwards for negative loads).
                        
                        # Scale factor for visualization. Adjust as needed.
                        load_scale = 0.2 
                        
                        # Determine the effective Y positions based on load magnitude (downward is negative)
                        # We reverse the sign of the load for plotting, so a negative Pynite load 
                        # results in a positive magnitude *height* above the layer_y.
                        h_start = abs(mag1 * load_scale)
                        h_end = abs(mag2 * load_scale)
                        
                        poly_vertices = np.array([
                            [x1, current_y],              # Bottom-left (on layer plane)
                            [x2, current_y],              # Bottom-right (on layer plane)
                            [x2, current_y + h_end],      # Top-right (at scaled magnitude)
                            [x1, current_y + h_start]     # Top-left (at scaled magnitude)
                        ])
                        
                        # Add the distributed load patch
                        poly = Polygon(poly_vertices, closed=True, color=color, 
                                           edgecolor=color, linewidth=1, alpha=0.5, zorder=3)
                        ax.add_patch(poly)
    
                        # Add the load text label and update the layer height
                        load_magnitude_label = f'{abs(mag1):.2f}|{abs(mag2):.2f}'
                        
                        # Plot arrows along the top edge of the polygon (simplified representation)
                        num_arrows = max(2, int((x2 - x1) / 2)) # Min 2 arrows
                        x_arrows = np.linspace(x1, x2, num_arrows)
                        
                        for x_arr in x_arrows:
                            # Interpolate the y-position for the top of the polygon
                            y_arr = current_y + (h_start * (x2 - x_arr) + h_end * (x_arr - x1)) / (x2 - x1)
                            
                            # Draw a small downward arrow
                            ax.annotate(load_magnitude_label, xy=(x_arr, y_arr),
                                        arrowprops=dict(arrowstyle="->", color=color, linewidth=1.5),
                                        annotation_clip=False)
                        
                        # Update layer height to the maximum required height by this D.L.
                        layer_heights[case_name] = max(layer_heights.get(case_name, 0), current_y + max(h_start, h_end) + 0.2)
        
        # --- B. Point Loads ---
            for pt_load in element.PtLoads:
                direction, mag, loc, case = pt_load
                # Check for point loads (Forces)
                if case_name == case:
                    if mag != 0:
                        x_pos = loc
                        
                        # Draw a vertical arrow for the point load
                        arrow_length = 0.5 
                        
                        # Downward load in Pynite is F_y < 0
                        if mag < 0:
                            # Downward arrow: starts high, ends low
                            ax.annotate(f'{abs(mag):.1f}', 
                                        xy=(x_pos, current_y), 
                                        xytext=(x_pos, current_y + arrow_length),
                                        ha='center', va='bottom', color=color, zorder=4,
                                        arrowprops=dict(arrowstyle="->", color=color, 
                                                        linewidth=2),
                                        annotation_clip=False)
                        else: # Upward load (F_y > 0)
                            # Upward arrow: starts low, ends high
                            ax.annotate(f'{abs(mag):.1f}', 
                                        xy=(x_pos, current_y + arrow_length), 
                                        xytext=(x_pos, current_y),
                                        ha='center', va='top', color=color, zorder=4,
                                        arrowprops=dict(arrowstyle="->", color=color, 
                                                        linewidth=2,),
                                        annotation_clip=False)
                        
                        # Update layer height if point load extends higher
                        # Use a fixed height for point loads for simplicity in layering
                        layer_heights[case_name] = max(layer_heights.get(case_name, 0), current_y + arrow_length + 0.2)
    
    
            # --- C. Update Vertical Position for the Next Load Case Layer ---
            # The next load case will start above the highest point of the current case's loads.
            if case_name in layer_heights:
                y_offset = layer_heights[case_name] + layer_spacing * 0.5
            else:
                # If no loads were found, just increment to the next layer
                y_offset += layer_spacing 


    # --- 4. SET PLOT AESTHETICS ---
    
    # Determine plot limits based on beam extent
    x_min, x_max = min(X_coords), max(X_coords)
    x_range = x_max - x_min
    padding = x_range * 0.1
    
    # Set X limits
    ax.set_xlim(x_min - padding, x_max + padding)
    
    # Set Y limits: from below the supports up to the highest load layer
    max_load_y = y_offset - layer_spacing * 0.5 
    ax.set_ylim(support_height * 1.5, max_load_y + 0.5)
    ax.margins(0.3)
    
    # Set aspect ratio to make supports look like triangles/circles (not distorted)
    # ax.set_aspect('equal', adjustable='box') 
    ax.set_title('Layered Beam Free-Body Diagram')
    ax.set_xlabel('Position (X)')
    
    # Clean up axes
    ax.set_yticks([]) 
    ax.spines['left'].set_visible(False)
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    # Move bottom spine to Y=0 to represent the beam line
    ax.spines['bottom'].set_position(('data', Y_beam)) 
    
    # --- 5. LEGEND (Optional but helpful for load layers) ---
    
    # Create simple patches for the legend
    legend_handles = []
    for case_name, color in color_map.items():
        handle = Rectangle((0, 0), 1, 1, fc=color, ec=color, alpha=0.5)
        legend_handles.append(handle)
        
    ax.legend(legend_handles, load_case_names, title="Load Cases", loc='upper right', bbox_to_anchor = (1.2, 1))
    # ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.05),
    #       ncol=5, fancybox=True, shadow=True)
    
    return ax